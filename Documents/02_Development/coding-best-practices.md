# Eede コーディングベストプラクティス

## Eede コーディングベストプラクティス 要約

このドキュメントは、Eede 開発におけるコーディングに関する良い方法をまとめたものです。

1.  **実装の基本**:
   *   SOLID 原則、 DRY の原則、 KISS の原則の実践。

2.  **UI/UX の基本**:
    *   画面は、どんな大きさのデバイスでも見やすくします。
    *   ユーザーが操作した結果を分かりやすく表示します。
    *   誰もが使いやすいように、アクセシビリティに配慮します。

3.  **テストの基本**:
    *   プログラムが正しく動くか、テストをしっかり行います。
    *   テストは、プログラムを作る前に書きます。

4.  **セキュリティの基本**:
    *   ユーザーからの入力は、安全かどうか確認します。
    *   大切な情報は、きちんと守ります。

5.  **デバッグとトラブルシューティングの基本**:
    *   問題が起きたときは、ログを記録して原因を調べます。

6.  **パフォーマンス最適化の基本**:
    *   プログラムの動きを速くするために、メモリの使い方や画像処理などを工夫します。

7.  **コード品質の維持**:
    *   プログラムは、常に改善を続けます。

8.  **ドキュメンテーションの基本**:
    *   コードが何をするものか、分かりやすく説明します。

9.  **開発プロセス**:
    *   コードの変更を記録し、チームで協力して開発を進めます。


## 1. コード設計原則

### 1.1 SOLID 原則の実践

- 単一責任の原則（SRP）:1 つのクラスは 1 つの責任のみを持つ
- オープン・クローズドの原則（OCP）:拡張に対して開かれ、修正に対して閉じている
- リスコフの置換原則（LSP）:継承は適切に使用する
- インターフェース分離の原則（ISP）:インターフェースは小さく保つ
- 依存性逆転の原則（DIP）:抽象に依存し、具象に依存しない

### 1.2 DRY の原則(Don't Repeat Yourself)

- コードの重複を避ける
- 共通のロジックは適切に抽象化する
- ユーティリティクラスを活用する

### 1.3 KISS(Keep It Simple, Stupid)

- シンプルな解決策を優先する
- 過度な抽象化を避ける
- 読みやすさを重視する


## 2. 実装のベストプラクティス

### 2.1 パフォーマンス

- 大きな画像処理は非同期で実行
- メモリ使用量を監視
- 適切なキャッシング戦略を使用

```csharp
// 良い例:非同期処理の使用
public async Task<Picture> LoadLargeImageAsync(string path)
{
    return await Task.Run(() => LoadImage(path));
}
```

### 2.2 エラーハンドリング

- 例外は適切な粒度でキャッチ
- ユーザーフレンドリーなエラーメッセージを提供
- ログ記録を適切に行う

```csharp
try
{
    await ProcessImageAsync(path);
}
catch (OutOfMemoryException ex)
{
    logger.Error(ex, "画像処理中にメモリ不足が発生しました");
    await ShowErrorDialog("メモリ不足のため処理を完了できません。他のアプリケーションを閉じて再試行してください。");
}
```

### 2.3 リソース管理

- using ステートメントで確実にリソースを解放
- メモリリークに注意
- 大きなリソースは適切にディスポーズ

```csharp
public async Task SaveImageAsync(string path)
{
    using var fileStream = new FileStream(path, FileMode.Create);
    await image.SaveAsync(fileStream);
}
```

## 3. UI/UX のベストプラクティス

### 3.1 レスポンシブ性

- 重い処理は別スレッドで実行
- プログレスバーで進捗を表示
- UI のフリーズを防止

### 3.2 ユーザーフィードバック

- 操作の結果を明確に表示
- エラーメッセージは具体的で解決策を提示
- 長時間の処理は推定時間を表示

### 3.3 アクセシビリティ

- キーボード操作のサポート
- スクリーンリーダーの対応
- 十分なコントラスト比の確保

## 4. テストのベストプラクティス

#### Given-When-Then 形式

BDDは、システムの振る舞いを「Given（前提条件）-When（アクション）-Then（結果）」の形式で記述することで、関係者間の共通理解を深める開発手法です。

1. Given: 特定の前提条件が整っている状態
2. When: ユーザーが特定のアクションを実行する
3. Then: 期待される結果が発生する

```csharp
// 例:電卓アプリケーションの加算機能
// Given: 電卓が起動しており、数値 5 が入力されている
// When: 数値 3 を入力し、加算ボタンを押す
// Then: 画面に 8 が表示される

[Test]
public void Add_TwoNumbers_ReturnsSum()
{
    // Given
    var calculator = new Calculator();
    calculator.Enter(5);

    // When
    calculator.Enter(3);
    calculator.PressAdd();

    // Then
    Assert.That(calculator.Display, Is.EqualTo(8));
}

public class Calculator
{
    public int Display { get; private set; }

    public void Enter(int number)
    {
        Display = number;
    }

    public void PressAdd()
    {
        // 加算処理の実装
    }
}
```

#### BDDの利点

- 関係者間のコミュニケーションが円滑になる
- 開発の初期段階で要件の誤解を防ぐことができる
- テストが仕様書としての役割を果たす
- 開発者は、何を作るべきかを明確に理解できる

#### BDDの実践ガイドライン

- ユーザーの視点から振る舞いを記述する
- 具体的なシナリオを使用する
- 「Given-When-Then」の形式で記述する
- 自動化されたテストを作成する

#### 振る舞いの設計方法

1.  **ユーザーの視点から記述する:** システムがどのように振る舞うべきかを、ユーザーの視点から記述します。
2.  **具体的なシナリオを使用する:** 具体的なシナリオを使用し、「Given-When-Then」の形式で記述します。
3.  **関係者と協力する:** 関係者と協力して、振る舞いを明確にします。
4.  **自動化されたテストで検証する:** 振る舞いを自動化されたテストで検証します。

#### 振る舞いの記述方法のテンプレート

```
Feature: [機能名]
  As a [役割]
  I want [目的]
  So that [理由]

  Scenario: [シナリオ名]
    Given [前提条件]
    When [アクション]
    Then [結果]
```

## 5. セキュリティのベストプラクティス

### 5.1 入力検証

- すべてのユーザー入力を検証
- ファイルアップロードの制限
- パスの正規化

### 5.2 データ保護

- 機密情報の適切な保護
- 一時ファイルの安全な処理
- セキュアな保存場所の使用

## 6. デバッグとトラブルシューティング

### 6.1 ログ記録

- 適切なログレベルの使用
- コンテキスト情報の記録
- パフォーマンスメトリクスの記録

### 6.2 診断

- デバッグシンボルの管理
- メモリダンプの分析
- プロファイリングツールの活用

## 7. パフォーマンス最適化

### 7.1 メモリ管理

- 大きなオブジェクトは適切に解放
- メモリプールの使用
- 不要なオブジェクトの削除

### 7.2 画像処理

- 適切な画像フォーマットの選択
- リサイズ処理の最適化
- キャッシュの活用

## 8. コード品質の維持

### 8.1 コードレビュー

- レビューチェックリストの使用
- 建設的なフィードバック
- 知識共有の促進

### 8.2 継続的な改善

- 技術的負債の管理
- リファクタリングの計画
- パフォーマンスモニタリング

## 9. ドキュメンテーション

### 9.1 コードドキュメント

- 意図の明確な記述
- サンプルコードの提供
- 注意点の明記

### 9.2 API ドキュメント

- 完全な API リファレンス
- ユースケースの例示
- エラーケースの説明

## 10. 開発プロセス

### 10.1 バージョン管理

- 意味のあるコミットメッセージ
- 適切なブランチ戦略
- プルリクエストの品質管理

### 10.2 継続的インテグレーション

- 自動テストの実行
- ビルド検証
- コード品質チェック

このドキュメントは実際のプロジェクト経験に基づいて定期的に更新されます。
新しいベストプラクティスの発見や既存のプラクティスの改善提案は、チーム内で共有し議論することを推奨します。
